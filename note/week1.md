:::note
**今週のまとめ**
- とにかく、高度で難解なプログラムへの憧れを捨て、すっきりとシンプルなコードを書くようにする
- 最初から完璧を目指さず、後からまとめ上げていくようにする
- まず具体的な図示などを用いて問題整理！解法の流れを確認！(視覚化した方が色々思いつきやすい)
:::

# Homework

## 振り返り
### 考えていたことと実際に試したこと
- 今はアルファベット、それも小文字だけだから26種類で済んでいるけど、言語や条件が変わればこの限りではない
　→ 比較回数が多くなっても対応できるようにハッシュ化しておこう
- そのままだとハッシュの衝突が起こってしまう
　→ 文字列の長さによる確認を行うことで確率を下げよう
　→ modの取り方を2種類用意してもいいかもしれない
- 問題の制限がわからない限り問題は解けない(競プロに慣れすぎ)
　→ inputのファイルから情報を取り出すプログラムを作って、まず問題の制約を確認しよう
### よくなかった点
- 完璧主義すぎた、最初から完璧を目指そうとしていた
- 複雑で難解なプログラムの方が優れていると思っていた
- ハッシュの衝突により、誤答が出てしまう可能性が捨てきれなかった 完全な正答ではなかった
- 本番環境ではnの大きさが事前に想定できないことも多い
### Office Hourでもらったアドバイス
- Heuristicのように、まず貪欲解を作る → structにまとめる、アルゴリズムを適用するなどして最適化
- まず書き出して、そこからまとめ上げていく(最初から完璧なものを作ろうとすると瓦解する)
- 高度でマルチなプログラムよりも、すっきりと単純で共有しやすいコードの方が業務では好まれる

## 思いついたこと / これから試すこと
- 累積和でa-zの登場回数を管理、累積和的に登場回数の一致判定をすることで二分探索的に回数を減らすことができるのではないか?
　- この場合、最悪比較回数は2倍に増えるが期待値としては減りそうな気がする 検証する
- スコアの高い順に比較を行い、一致するものが出たら終了 → 期待値としては比較回数が減らせる
- 疑似コードやメモなどを用いて、まずは解法をクリアに
