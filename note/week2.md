:::note
**今週のまとめ**
- 計算量の概念は大事、計算量を意識して解法を選択しよう
- 定数倍の時間削減は後回し、可読性とのバランスをとりながら
- 実際のプロダクトにおいては問題の制約は確認できないと思った方が良い
- 絶対的な位置を保存しておくと、横にスライドした時のindexの変更が大変
- ポインタで相対的な位置を記録した連想配列が効果的
:::


# Class

## 意識すべきこと
- 計算量の概念はアルゴリズムの良し悪しを判断するための指標
　→ 解法選択をしたり、コードの最適化をするにあたって、まず意識する必要がある
- オーダー記法では定数倍の掛け算は無視される
　→ 解放選択の際も、最初は定数倍の時間削減にはこだわらない
- 実際のプロダクトにおいては、Nを予測できないことが多い
　→ オーダー記法に則って、より計算量の小さいアルゴリズムを作っておくことが大事！
　(Week1の宿題のように問題の制約を確認することはできないと思った方がいい)

## 例外 : O(NlogN)よりもO(N^2)を選んだ方がいい場合
- Nが十分に小さい場合
　- 定数係数次第ではO(N^2)の方が優れているかも
　- 可読性の高さの方が重視されるかも
**オーダー記法では無視されてしまうが、実際には定数係数も大事！**
ユーザーに提供するものはとにかく速さを追求する必要があるが、自社の開発者しか使わないようなものはメンテナンスにかかる人的コストなどを考え、より自明で遅いアルゴリズムが選択されることもある

## その他面白かった話
- 現実世界では、ハードウェアの故障や宇宙船の影響でデータが思い通りに扱えないことも多い



# Homework

## 振り返り
### 考えていたことと実際に試したこと
### よくなかった点
- 「コンパクトな方が嬉しい」の考え方が抜けていた
- CSに関する知識がない アルゴリズムの仕組みばかり考えてそれを動かすコンピュータの都合を考えられていない
### Office Hourでもらったアドバイス
- キャッシュについて考えてみよう データが集約していた方が計算しやすい
- Object思考: 使いたい操作を考えてから構造体を実装することで、後から中身をいじった時に芋づる的に詰まない
- どこが時間を食っているのか、操作ごとに測って重みづけをする、寄与率の高いものから改善を考えていく
- セキュリティ向上のためのハッシュについて、何が漏洩しやすいのか考えていなかった
- using namespace stdでの省略はあんまりやらないかも

## これから試してみること


# todo
