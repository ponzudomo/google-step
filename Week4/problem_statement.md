# 問題文一覧

## Extra
### 問題文
> 挑戦クイズ：再帰版 DFS と同じたどり方をする DFS をスタックを使って書いてみよう！🤔🤔🤔
> [サンプルプログラム](https://github.com/xharaken/step2/blob/master/dfs.py)
### 実装方針
- 多次元stack

　  
# Homework 全体のコンセプト
> 日本語 Wikipedia の全ページのタイトルとリンク関係のデータセットを提供します
> - ページ数：2,215,900
> - リンク数：119,006,494
> グラフ解析をして「おもしろい知識」を発見しよう！！(*•̀ᴗ•́*)و

## Homework1
### 問題文
> find_shortest_path() 関数を書いて、あるページから別のページへの最短経路を出力してください😀
> 「渋谷」から「小野妹子」にどうたどり着く？
### 実装方針
- ~~普通にダイクストラ法~~
- 重みがついていませんでした BFS

## Homework2
### 問題文
> find_most_popular_pages() 関数を書いて、ページランクを計算して重要度の高いページトップ 10 を求めてください
> 「言葉で説明したアルゴリズムを自分で具体化してコードに落とす」のが宿題の意図です
> 
> ページランクの更新が「完全に」収束するのは時間がかかりすぎるので、更新が十分少なくなったら止める
> 収束条件の作り方の例：
> `∑(new_pagerank[i] - old_pagerank[i])^2 < 0.01` 
### 実装方針
- Random Surferモデル
- ノード P のページランクの 85% は隣接ノードに均等に分配する + 残りの 15% は全ノードに均等に分配する
- もしノード P に隣接ノードがない場合、100% を全ノードに均等に分配する

## Homework3
### 問題文
> Wikipedia のグラフについて「渋谷」から「池袋」まで、同じページを重複して通らない、できるだけ長い経路を発見してください！！
- ほのかに巡回セールスマンに似ているが、並び替えではなく巡回するノード自体の選択が必要...
- 重みはない
### 案
- 
- ビームサーチっぽくグラフを探索して初期解を適当に作成
- chokudaiサーチ
- 初期解はランダムに複数生成して、GRASP風味にするのが良い気がする
- Fold-Fulkerson法みたいに巻き戻しを可能にするとよさそう
　- ノードに通過したか否かのflagを立てる
　- flag = falseなら全てのEdgeが使える
　- trueなら逆向きのEdgeのみ通れる
　- 逆向きのEdgeを通ったらflag = falseに戻す
- 全てのEdgeの容量を1としてフローを流しまくる → 通ったEdgeの数をスコアとして焼きなまし？
- 最初は2-3分で切り上げてもらって様子を見る、大丈夫そうだったら徐々に時間を増やしていき数時間回す

 <details><summary>ボツ集</summary>

### ボツ案1
> ~~dp[pos][to] = posからtoまでの最長のルート？~~

<br>
この場合訪問済みのノードを通らないように訪問先を記録しておく必要があり、現実的でない

### ボツ案2
> ~~強連結成分(SCC)分解~~
> ~~SCC内の最長パスをビームサーチか何かで調べる~~
> ~~潰して閉路を持たない有向グラフ(DAG)にする~~
> ~~DAG上でDPを回す~~

<br>
嘘です SCCの定義を誤認していました

</details>

### todo
- 時間の取得がどのくらい重い作業なのかを調べる
　- キツそうだったら数回に一回取得とかにする
- HW2で求めたページランクをどうにか活用したい
　- ランクの低い(=使いづらい)ページを優先的に通っていくと後々選択肢が増えそう？
　- ページランクなどを入れ込んで、スコアの評価関数をセマンティックにしてもよい
- 渋谷と池袋の両方に繋がらないノードは、予め枝刈りしておくと楽かも
